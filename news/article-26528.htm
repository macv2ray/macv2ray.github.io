<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN" class="no-js">

<head>
        <link rel="canonical" href="https://macv2ray.github.io/news/article-26528.htm" />
    <meta charset="utf-8" />
    <title>【TypeScript】TypeScript 与 JavaScript 有何不同？</title>
        <meta name="description" content="自我介绍：大家好，我是吉帅振的网络日志（其他平台账号名字相同），互联网前端开发工程师，工作5年，去过上海和北京，经历创业公司，加入过阿里本地生活团队，现在郑州北游教育从事编程培训。  一、前言 Typ" />
        <link rel="icon" href="/assets/website/img/macv2ray/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="Mac V2ray机场节点订阅分享">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://macv2ray.github.io/news/article-26528.htm" />
    <meta property="og:site_name" content="Mac V2ray机场节点订阅分享" />
    <meta property="og:title" content="【TypeScript】TypeScript 与 JavaScript 有何不同？" />
    <meta property="og:image" content="https://macv2ray.github.io/uploads/20240907-2/ea71a405cc37554b0a456f87965ae585.webp" />
        <meta property="og:release_date" content="2024-12-16T10:12:02" />
    <meta property="og:updated_time" content="2024-12-16T10:12:02" />
        <meta property="og:description" content="自我介绍：大家好，我是吉帅振的网络日志（其他平台账号名字相同），互联网前端开发工程师，工作5年，去过上海和北京，经历创业公司，加入过阿里本地生活团队，现在郑州北游教育从事编程培训。  一、前言 Typ" />
        
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1" name="viewport" />

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="【TypeScript】TypeScript 与 JavaScript 有何不同？">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">

    <!-- GLOBAL MANDATORY STYLES -->
    <link href="http://fonts.googleapis.com/css?family=Hind:300,400,500,600,700" rel="stylesheet" type="text/css">
    <link href="/assets/website/js/frontend/macv2ray/simple-line-icons/css/simple-line-icons.css" rel="stylesheet" type="text/css" />
    <link href="/assets/website/js/frontend/macv2ray/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <!-- PAGE LEVEL PLUGIN STYLES -->
    <link href="/assets/website/css/macv2ray/animate.css" rel="stylesheet">
    <link href="/assets/website/js/frontend/macv2ray/swiper/css/swiper.min.css" rel="stylesheet" type="text/css" />
    <link href="/assets/website/js/frontend/macv2ray/magnific-popup/magnific-popup.css" rel="stylesheet" type="text/css" />
    <!-- THEME STYLES -->
    <link href="/assets/website/css/macv2ray/layout.min.css" rel="stylesheet" type="text/css" />
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F98P9DTHJY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F98P9DTHJY');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body id="body" data-spy="scroll" data-target=".header" data-page="detail">
        <!--========== HEADER ==========-->
    <header class="header navbar-fixed-top">
        <!-- Navbar -->
        <nav class="navbar" role="navigation">
            <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="menu-container js_nav-item">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="toggle-icon"></span>
                    </button>
                    <!-- Logo -->
                    <div class="logo">
                                                <a class="logo-wrap" href="/">
                            <span>Mac V2ray</span>
                        </a>
                                            </div>
                    <!-- End Logo -->
                </div>
                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse nav-collapse">
                    <div class="menu-container">
                        <ul class="nav navbar-nav navbar-nav-right">
                                                        <li class="nav-item"><a class="nav-item-child nav-item-hover" href="/">首页</a></li>
                                                        <li class="nav-item"><a class="nav-item-child nav-item-hover" href="/free-nodes/">免费节点</a></li>
                                                        <li class="nav-item"><a class="nav-item-child nav-item-hover" href="/paid-subscribe/">推荐机场</a></li>
                                                        <li class="nav-item"><a class="nav-item-child nav-item-hover" href="/news/">新闻资讯</a></li>
                                                        <li class="nav-item"><a class="nav-item-child nav-item-hover" href="#">关于</a></li>
                            <li class="nav-item"><a class="nav-item-child nav-item-hover" href="#">联系</a></li>
                        </ul>
                    </div>
                </div>
                <!-- End Navbar Collapse -->
            </div>
        </nav>
        <!-- Navbar -->
    </header>
    <!--========== END HEADER ==========-->
    <!--========== SLIDER ==========-->
    <div class="promo-block">
        <div class="container">
            <div class="margin-b-40">
                <h1 class="promo-block-title">【TypeScript】TypeScript 与 JavaScript 有何不同？</h1>
                <p class="promo-block-text">
                    <a href="/">首页</a> / <a href="/news/">新闻资讯</a> / 正文
                </p>
            </div>
        </div>
    </div>
    <!--========== SLIDER ==========-->
    <!--========== PAGE LAYOUT ==========-->
    <!-- Products -->
    <div id="products">
        <div class="container content-lg">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="markdown_views prism-atom-one-dark"> <p><strong>自我介绍：大家好，我是<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fqian-duan-kai-fa-xiao-ren-wu"  title="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fqian-duan-kai-fa-xiao-ren-wu" rel="nofollow">吉帅振的网络日志</a>（其他平台账号名字相同），互联网前端开发工程师，工作5年，去过上海和北京，经历创业公司，加入过阿里本地生活团队，现在郑州北游教育从事编程培训。</strong></p> <h3> <a id="_2" rel="nofollow"></a>一、前言</h3> <p>TypeScript 其实就是类型化的 JavaScript，它不仅支持 JavaScript 的所有特性，还在 JavaScript 的基础上添加了静态类型注解扩展。从某种意义上来说，TypeScript 其实就是 JavaScript 的超集。在 TypeScript 中，我们不仅可以轻易复用 JavaScript 的代码、最新特性，还能使用可选的静态类型进行检查报错，使得编写的代码更健壮、更易于维护。比如在开发阶段，我们通过 TypeScript 代码转译器就能快速消除很多低级错误（如 typo、类型等）。</p> <h3> <a id="_6" rel="nofollow"></a>二、基本语法</h3> <p>在语法层面，缺省类型注解的 TypeScript 与 JavaScript 完全一致。因此，我们可以把 TypeScript 代码的编写看作是为 JavaScript 代码添加类型注解。在 TypeScript 语法中，类型的标注主要通过类型后置语法来实现。</p> <pre><code>let num = 1; </code></pre> <p>示例中的语法同时符合 JavaScript 语法和 TypeScript 语法。而 TypeScript 语法与 JavaScript 语法的区别在于，我们可以在 TypeScript 中显式声明变量num仅仅是数字类型，也就是说只需在变量num后添加: number类型注解即可</p> <pre><code>let num: number = 1; </code></pre> <h3> <a id="_18" rel="nofollow"></a>三、原始类型</h3> <p>在 JavaScript 中，原始类型指的是非对象且没有方法的数据类型，它包括 string、number、bigint、boolean、undefined 和 symbol 这六种 （null 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）。在 JavaScript 语言中，原始类型值是最底层的实现，对应到 TypeScript 中同样也是最底层的类型。</p> <p>1.字符串</p> <p>在 JavaScript 中，我们可以使用string表示 JavaScript 中任意的字符串（包括模板字符串）</p> <pre><code>let firstname: string = 'Captain'; // 字符串字面量 let familyname: string = String('S'); // 显式类型转换 let fullname: string = `my name is ${firstname}.${familyname}`; // 模板字符串 </code></pre> <p>2.数字</p> <p>number类型表示 JavaScript 已经支持或者即将支持的十进制整数、浮点数，以及二进制数、八进制数、十六进制数</p> <pre><code>/** 十进制整数 */ let integer: number = 6; /** 十进制整数 */ let integer2: number = Number(42); /** 十进制浮点数 */ let decimal: number = 3.14; /** 二进制整数 */ let binary: number = 0b1010; /** 八进制整数 */ let octal: number = 0o744; /** 十六进制整数 */ let hex: number = 0xf00d; </code></pre> <p>如果使用较少的大整数，那么我们可以使用bigint类型来表示</p> <pre><code>let big: bigint =  100n; </code></pre> <p>3.布尔值</p> <p>boolean表示 True 或者 False</p> <pre><code>/** TypeScript 真香 为 真 */ let TypeScriptIsGreat: boolean = true;  /** TypeScript 太糟糕了 为 否 */ let TypeScriptIsBad: boolean = false; Symbol </code></pre> <p>4.Symbol原始类型</p> <p>我们可以通过Symbol构造函数，创建一个独一无二的标记</p> <pre><code>let sym1: symbol = Symbol(); let sym2: symbol = Symbol('42'); </code></pre> <p>当然，TypeScript 还包含 Number、String、Boolean、Symbol 等类型（注意区分大小写）。</p> <pre><code>let sym: symbol = Symbol('a'); let sym2: Symbol = Symbol('b'); sym = sym2 // ok or fail? sym2 = sym // ok or fail? let str: String = new String('a'); let str2: string = 'a'; str = str2; // ok or fail? str2 = str; // ok or fail? </code></pre> <p>实际上，我们压根使用不到 Number、String、Boolean、Symbol 类型，因为它们并没有什么特殊的用途。这就像我们不必使用 JavaScript Number、String、Boolean 等构造函数 new 一个相应的实例一样。</p> <pre><code>{   let mustBeNum = 1; } {   let mustBeNum: number = 1; } </code></pre> <p>下面，我们对上面的示例稍做一下修改</p> <pre><code>{   let mustBeNum = 'badString'; } {   let mustBeNum: number = 'badString'; } </code></pre> <p>如果变量所处的上下文环境特别复杂，在开发阶段就能检测出低级类型错误的能力将显得尤为重要，而这种能力主要来源于 TypeScript 实现的静态类型检测。</p> <p>5.静态类型检测</p> <p>在编译时期，静态类型的编程语言即可准确地发现类型错误，这就是静态类型检测的优势。在编译（转译）时期，TypeScript 编译器将通过对比检测变量接收值的类型与我们显示注解的类型，从而检测类型是否存在错误。如果两个类型完全一致，显示检测通过；如果两个类型不一致，它就会抛出一个编译期错误，告知我们编码错误，具体示例如下代码所示：</p> <pre><code>const trueNum: number = 42; const fakeNum: number = "42"; // ts(2322) Type 'string' is not assignable to type 'number'. </code></pre> <p>在以上示例中，首先我们声明了一个数字类型的变量trueNum，通过编译器检测后，发现接收值是 42，且它的类型是number，可见两者类型完全一致。此时，TypeScript 编译器就会显示检测通过。而如果我们声明了一个string类型的变量fakeNum，通过编译器检测后，发现接收值为 “42”，且它的类型是number，可见两者类型不一致 。此时，TypeScript 编译器就会抛出一个字符串值不能为数字类型变量赋值的ts(2322) 错误，也就是说检测不通过。TypeScript 的语言服务可以和 VS Code 完美集成。因此，在编写代码的同时，我们可以同步进行静态类型检测（无须等到编译后再做检测），极大地提升了开发体验和效率。</p> <h3> <a id="_111" rel="nofollow"></a>四、引用类型</h3> <p>1.数组</p> <p>因为 TypeScript 的数组和元组转译为 JavaScript 后都是数组，所以这里我们把数组和元组这两个类型整合到一起介绍，也方便你更好地对比学习。</p> <p>2.数组类型（Array）</p> <p>在 TypeScript 中，我们也可以像 JavaScript 一样定义数组类型，并且指定数组元素的类型。</p> <pre><code>/** 子元素是数字类型的数组 */ let arrayOfNumber: number[] = [1, 2, 3]; /** 子元素是字符串类型的数组 */ let arrayOfString: string[] = ['x', 'y', 'z']; </code></pre> <p>可以使用 Array 泛型定义数组类型</p> <pre><code>/** 子元素是数字类型的数组 */ let arrayOfNumber: Array&lt;number&gt; = [1, 2, 3]; /** 子元素是字符串类型的数组 */ let arrayOfString: Array&lt;string&gt; = ['x', 'y', 'z']; </code></pre> <p>以上两种定义数组类型的方式虽然本质上没有任何区别</p> <pre><code>let arrayOfNumber: number[] = ['x', 'y', 'z']; // 提示 ts(2322) arrayOfNumber[3] = 'a'; // 提示 ts(2322) arrayOfNumber.push('b'); // 提示 ts(2345) let arrayOfString: string[] = [1, 2, 3]; // 提示 ts(2322) arrayOfString[3] = 1; // 提示 ts(2322) arrayOfString.push(2); // 提示 ts(2345) </code></pre> <p>3.元组类型（Tuple）</p> <p>元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。我们熟知的一个使用元组的场景是 React Hooks（关于 React Hooks 的简介请点击这里查看），例如 useState 示例：</p> <pre><code>import { useState } from 'react'; function useCount() {   const [count, setCount] = useState(0);   return ....; } </code></pre> <p>在 JavaScript 中并没有元组的概念，作为一门动态类型语言，它的优势是天然支持多类型元素数组。我们假设以下两个数组的元素类型如下代码所示：</p> <pre><code>[state, setState] [setState, state] </code></pre> <p>从上面可以看出，state 是一个类型为 State 的对象，而 setState 是一个类型为 SetState 的函数。注意：这里我们用全小写表示值，首字母大写表示（TypeScript）类型。对于 JavaScript 而言，上面的数组其实长的都一样，并没有一个有效的途径可以区分彼此。不过，出于较好的扩展性、可读性和稳定性考虑，我们往往会更偏向于把不同类型的值通过键值对的形式塞到一个对象中，再返回这个对象（尽管这样会增加代码量），而不是使用没有任何限制的数组。比如我们可能会使用如下的对象结构来替换数组：</p> <pre><code>{   state,   setState } </code></pre> <p>而 TypeScript 的元组类型正好弥补了这个不足，使得定义包含固定个数元素、每个元素类型未必相同的数组成为可能。（需要注意的是，毕竟 TypeScript 会转译成 JavaScript，所以 TypeScript 的元组无法在运行时约束所谓的“元组”像真正的元组一样，保证元素类型、长度不可变更）。对于 TypeScript 而言，如下所示的两个元组类型其实并不相同：</p> <pre><code>[State, SetState] [SetState, State] </code></pre> <p>所以添加了不同元组类型注解的数组后，在 TypeScript 静态类型检测层面就变成了两个不相同的元组，如下代码所示：</p> <pre><code>const x: [State, SetState] = [state, setState]; const y: [SetState, State] = [setState, state]; </code></pre> <p>下面我们还是使用所熟知的 React Hooks 来介绍 TypeScript 元组的应用场景。比如 useState 的返回值类型是一个元组类型，如下代码所示（以下仅是简单的例子，事实上 useState 的类型定义更为复杂）：</p> <pre><code>(state: State) =&gt; [State, SetState] </code></pre> <p>元组相较对象而言，不仅为我们实现解构赋值提供了极大便利，还减少了不少代码量，这可能也是 React 官方如此设计核心 Hooks 的重要原因之一。但事实上，许多第三方的 Hooks 往往会出于扩展性、稳定性等考虑，尤其是需要返回的值的个数超过 2 个时，会更偏向于使用对象作为返回值。</p> <ol start="4"> <li>any</li> </ol> <p>any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。我们可以对被注解为 any 类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且 TypeScript 还无法检测其属性是否存在、类型是否正确。比如我们可以把任何类型的值赋值给 any 类型的变量，也可以把 any 类型的值赋值给任意类型（除 never 以外）的变量，如下代码所示：</p> <pre><code>let anything: any = {}; anything.doAnything(); // 不会提示错误 anything = 1; // 不会提示错误 anything = 'x'; // 不会提示错误 let num: number = anything; // 不会提示错误 let str: string = anything; // 不会提示错误 </code></pre> <p>如果我们不想花费过高的成本为复杂的数据添加类型注解，或者已经引入了缺少类型注解的第三方组件库，这时就可以把这些值全部注解为 any 类型，并告诉 TypeScript 选择性地忽略静态类型检测。尤其是在将一个基于 JavaScript 的应用改造成 TypeScript 的过程中，我们不得不借助 any 来选择性添加和忽略对某些 JavaScript 模块的静态类型检测，直至逐步替换掉所有的 JavaScript。any 类型会在对象的调用链中进行传导，即所有 any 类型的任意属性的类型都是 any，如下代码所示：</p> <pre><code>let anything: any = {}; let z = anything.x.y.z; // z 类型是 any，不会提示错误 z(); // 不会提示错误 </code></pre> <p>这里我们需要明白且记住：Any is Hell（Any 是地狱）。从长远来看，使用 any 绝对是一个坏习惯。如果一个 TypeScript 应用中充满了 any，此时静态类型检测基本起不到任何作用，也就是说与直接使用 JavaScript 没有任何区别。因此，除非有充足的理由，否则我们应该尽量避免使用 any ，并且开启禁用隐式 any 的设置。</p> <ol start="5"> <li>unknown</li> </ol> <p>unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量。比如在多个 if else 条件分支场景下，它可以用来接收不同条件下类型各异的返回值的临时变量，如下代码所示：</p> <pre><code>let result: unknown; if (x) {   result = x(); } else if (y) {   result = y(); } ... </code></pre> <p>在 3.0 以前的版本中，只有使用 any 才能满足这种动态类型场景。与 any 不同的是，unknown 在类型上更安全。比如我们可以将任意类型的值赋值给 unknown，但 unknown 类型的值只能赋值给 unknown 或 any，如下代码所示：</p> <pre><code>let result: unknown; let num: number = result; // 提示 ts(2322) let anything: any = result; // 不会提示错误 </code></pre> <p>使用 unknown 后，TypeScript 会对它做类型检测。但是，如果不缩小类型（Type Narrowing），我们对 unknown 执行的任何操作都会出现如下所示错误：</p> <pre><code>let result: unknown; result.toFixed(); // 提示 ts(2571) </code></pre> <p>而所有的类型缩小手段对 unknown 都有效，如下代码所示：</p> <pre><code>let result: unknown; if (typeof result === 'number') {   result.toFixed(); // 此处 hover result 提示类型是 number，不会提示错误 } </code></pre> <ol start="6"> <li>void、undefined、null</li> </ol> <p>考虑再三，我们还是决定把 void、undefined 和 null “三废柴”特殊类型整合到一起介绍。依照官方的说法，它们实际上并没有太大的用处，尤其是在本专栏中强烈推荐并要求的 strict 模式下，它们是名副其实的“废柴”。首先我们来说一下 void 类型，它仅适用于表示没有返回值的函数。即如果该函数没有返回值，那它的类型就是 void。在 strict 模式下，声明一个 void 类型的变量几乎没有任何实际用处，因为我们不能把 void 类型的变量值再赋值给除了 any 和 unkown 之外的任何类型变量。然后我们说说 undefined 类型 和 null 类型，它们是 TypeScript 值与类型关键字同名的唯二例外。但这并不影响它们被称为“废柴”，因为单纯声明 undefined 或者 null 类型的变量也是无比鸡肋，示例如下所示：</p> <pre><code>let undeclared: undefined = undefined; // 鸡肋 let nullable: null = null; // 鸡肋 </code></pre> <p>undefined 的最大价值主要体现在接口类型上，它表示一个可缺省、未定义的属性。这里分享一个稍微有点费解的设计：我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型。</p> <pre><code>const userInfo: {   id?: number; } = {}; let undeclared: undefined = undefined; let unusable: void = undefined; unusable = undeclared; // ok undeclared = unusable; // ts(2322) </code></pre> <p>而 null 的价值我认为主要体现在接口制定上，它表明对象或属性可能是空值。尤其是在前后端交互的接口，比如 Java Restful、Graphql，任何涉及查询的属性、对象都可能是 null 空对象，如下代码所示：</p> <pre><code>const userInfo: {   name: null | string } = { name: null }; </code></pre> <p>除此之外，undefined 和 null 类型还具备警示意义，它们可以提醒我们针对可能操作这两种（类型）值的情况做容错处理。我们需要类型守卫（Type Guard，第 11 讲会专门讲解）在操作之前判断值的类型是否支持当前的操作。类型守卫既能通过类型缩小影响 TypeScript 的类型检测，也能保障 JavaScript 运行时的安全性，如下代码所示：</p> <pre><code>const userInfo: {   id?: number;   name?: null | string } = { id: 1, name: 'Captain' }; if (userInfo.id !== undefined) { // Type Guard   userInfo.id.toFixed(); // id 的类型缩小成 number } </code></pre> <p>我们不建议随意使用非空断言（下面要讲的“类型断言”中会详细介绍非空断言）来排除值可能为 null 或 undefined 的情况，因为这样很不安全。</p> <pre><code>userInfo.id!.toFixed(); // ok，但不建议 userInfo.name!.toLowerCase() // ok，但不建议 </code></pre> <p>而比非空断言更安全、类型守卫更方便的做法是使用单问号（Optional Chain）、双问号（空值合并），我们可以使用它们来保障代码的安全性，如下代码所示：</p> <pre><code>userInfo.id?.toFixed(); // Optional Chain const myName = userInfo.name?? `my name is ${info.name}`; // 空值合并 </code></pre> <ol start="7"> <li>never</li> </ol> <p>never 表示永远不会发生值的类型，这里我们举一个实际的场景进行说明。首先，我们定义一个统一抛出错误的函数，代码示例如下（圆括号后 : + 类型注解 表示函数返回值的类型，关于函数类型我们会在后续 “第 5 讲：函数类型”详细讲解）：</p> <pre><code>function ThrowError(msg: string): never {   throw Error(msg); } </code></pre> <p>以上函数因为永远不会有返回值，所以它的返回值类型就是 never。同样，如果函数代码中是一个死循环，那么这个函数的返回值类型也是 never，如下代码所示。</p> <pre><code>function InfiniteLoop(): never {   while (true) {} } </code></pre> <p>never 是所有类型的子类型，它可以给所有类型赋值，如下代码所示。</p> <pre><code>let Unreachable: never = 1; // ts(2322) Unreachable = 'string'; // ts(2322) Unreachable = true; // ts(2322) let num: number = Unreachable; // ok let str: string = Unreachable; // ok let bool: boolean = Unreachable; // ok </code></pre> <p>但是反过来，除了 never 自身以外，其他类型（包括 any 在内的类型）都不能为 never 类型赋值。在恒为 false 的类型守卫条件判断下，变量的类型将缩小为 never（never 是所有其他类型的子类型，所以是类型缩小为 never，而不是变成 never）。因此，条件判断中的相关操作始终会报无法更正的错误（我们可以把这理解为一种基于静态类型检测的 Dead Code 检测机制），如下代码所示：</p> <pre><code>const str: string = 'string'; if (typeof str === 'number') {   str.toLowerCase(); // Property 'toLowerCase' does not exist on type 'never'.ts(2339) } </code></pre> <p>基于 never 的特性，我们还可以使用 never 实现一些有意思的功能。比如我们可以把 never 作为接口类型下的属性类型，用来禁止写接口下特定的属性，示例代码如下：</p> <pre><code>const props: {   id: number,   name?: never } = {   id: 1 } props.name = null; // ts(2322)) props.name = 'str'; // ts(2322) props.name = 1; // ts(2322) </code></pre> <p>此时，无论我们给 props.name 赋什么类型的值，它都会提示类型错误，实际效果等同于 name 只读 。</p> <ol start="8"> <li>object</li> </ol> <p>object 类型表示非原始类型的类型，即非 number、string、boolean、bigint、symbol、null、undefined 的类型。然而，它也是个没有什么用武之地的类型，如下所示的一个应用场景是用来表示 Object.create 的类型。</p> <pre><code>declare function create(o: object | null): any; create({}); // ok create(() =&gt; null); // ok create(2); // ts(2345) create('string'); // ts(2345) 类型断言（Type Assertion） </code></pre> <p>TypeScript 类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比 TypeScript 更清楚实际类型的情况，比如下面的例子：</p> <pre><code>const arrayNumber: number[] = [1, 2, 3, 4]; const greaterThan2: number = arrayNumber.find(num =&gt; num &gt; 2); // 提示 ts(2322) </code></pre> <p>其中，greaterThan2 一定是一个数字（确切地讲是 3），因为 arrayNumber 中明显有大于 2 的成员，但静态类型对运行时的逻辑无能为力。在 TypeScript 看来，greaterThan2 的类型既可能是数字，也可能是 undefined，所以上面的示例中提示了一个 ts(2322) 错误，此时我们不能把类型 undefined 分配给类型 number。不过，我们可以使用一种笃定的方式——类型断言（类似仅作用在类型层面的强制类型转换）告诉 TypeScript 按照我们的方式做类型检查。比如，我们可以使用 as 语法做类型断言，如下代码所示：</p> <pre><code>const arrayNumber: number[] = [1, 2, 3, 4]; const greaterThan2: number = arrayNumber.find(num =&gt; num &gt; 2) as number; </code></pre> <p>又或者是使用尖括号 + 类型的格式做类型断言，如下代码所示：</p> <pre><code>const arrayNumber: number[] = [1, 2, 3, 4]; const greaterThan2: number = &lt;number&gt;arrayNumber.find(num =&gt; num &gt; 2); </code></pre> <p>以上两种方式虽然没有任何区别，但是尖括号格式会与 JSX 产生语法冲突，因此我们更推荐使用 as 语法。注意：类型断言的操作对象必须满足某些约束关系，否则我们将得到一个 ts(2352) 错误，即从类型“源类型”到类型“目标类型”的转换是错误的，因为这两种类型不能充分重叠。我一度喜欢用“指鹿为马”来形容类型断言，但其实也不够准确。从物种类型上看，鹿和马肯定不能转换，虽然它们都是动物（继承自同一个父类），但是鹿有“角属性”，马有“鬃毛属性”，所以两者不能充分重叠。如果我们把它换成“指白马为马”“指马为白马”，就可以很贴切地体现类型断言的约束条件：父子、子父类型之间可以使用类型断言进行转换。我们除了可以把特定类型断言成符合约束添加的其他类型之外，还可以使用“字面量值 + as const”语法结构进行常量断言，具体示例如下所示：</p> <pre><code>/** str 类型是 '"str"' */ let str = 'str' as const; /** readOnlyArr 类型是 'readonly [0, 1]' */ const readOnlyArr = [0, 1] as const; </code></pre> <p>常量断言所涉及的字面量（字面量即代码中，比如 ‘“str”’、‘1’、‘true’、‘{}’）</p> <pre><code>let mayNullOrUndefinedOrString: null | undefined | string; mayNullOrUndefinedOrString!.toString(); // ok mayNullOrUndefinedOrString.toString(); // ts(2531) </code></pre> <p>对于非空断言来说，我们同样应该把它视作和 any 一样危险的选择。在复杂应用场景中，如果我们使用非空断言，就无法保证之前一定非空的值，比如页面中一定存在 id 为 feedback 的元素，数组中一定有满足 &gt; 2 条件的数字，这些都不会被其他人改变。而一旦保证被改变，错误只会在运行环境中抛出，而静态类型检测是发现不了这些错误的。</p> <pre><code>let mayNullOrUndefinedOrString: null | undefined | string; if (typeof mayNullOrUndefinedOrString === 'string') {   mayNullOrUndefinedOrString.toString(); // ok } </code></pre> <h3> <a id="_363" rel="nofollow"></a>五、小结</h3> <p>TypeScript 其实就是添加了类型注解的 JavaScript，它并没有任何颠覆性的变动。因此，学习并掌握 TypeScript 一定会是一件极其容易的事情。</p> </p></div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-26526.htm">Python格式化输出的三种方式：%、string.format()、f-string</a></p>
                                        <p>下一个：<a href="/news/article-26993.htm">动物疫苗过敏应该用什么药物急救处理好（动物疫苗反应有哪些）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-40403.htm" title="宠物到哪领养（宠物去哪里领养）">宠物到哪领养（宠物去哪里领养）</a></li>
                        <li class="py-2"><a href="/news/article-45363.htm" title="动物打的针叫什么（给动物打针打哪里）">动物打的针叫什么（给动物打针打哪里）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-11-free-high-speed-nodes.htm" title="Mac V2ray|1月11日→19.2M/S|最新Shadowrocket/Clash/SSR/V2ray免费节点链接地址">Mac V2ray|1月11日→19.2M/S|最新Shadowrocket/Clash/SSR/V2ray免费节点链接地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-12-node-share-links.htm" title="Mac V2ray|1月12日→19.4M/S|最新Shadowrocket/V2ray/Clash/SSR免费节点链接地址">Mac V2ray|1月12日→19.4M/S|最新Shadowrocket/V2ray/Clash/SSR免费节点链接地址</a></li>
                        <li class="py-2"><a href="/news/article-41387.htm" title="动物医院环评如何办理（宠物医院环评选址要求）">动物医院环评如何办理（宠物医院环评选址要求）</a></li>
                        <li class="py-2"><a href="/news/article-33605.htm" title="权力的游戏伯德瑞克（原创）权力的游戏 波德，斯巴达克斯结局，詹德利，">权力的游戏伯德瑞克（原创）权力的游戏 波德，斯巴达克斯结局，詹德利，</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-20-clash-v2ray-ss-ssr.htm" title="Mac V2ray|1月20日→21.5M/S|最新SSR/V2ray/Shadowrocket/Clash免费节点链接地址">Mac V2ray|1月20日→21.5M/S|最新SSR/V2ray/Shadowrocket/Clash免费节点链接地址</a></li>
                        <li class="py-2"><a href="/news/article-48263.htm" title="CEPH-4：ceph RadowGW对象存储功能详解">CEPH-4：ceph RadowGW对象存储功能详解</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-3-free-v2ray.htm" title="1月3日→21.1M/S|2025年最新免费节点Mac V2ray订阅链接地址">1月3日→21.1M/S|2025年最新免费节点Mac V2ray订阅链接地址</a></li>
                        <li class="py-2"><a href="/news/article-18718.htm" title="使用Jenkins实现前端自动化打包部署（Linux版本）">使用Jenkins实现前端自动化打包部署（Linux版本）</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">6</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </div>
    <!-- End Products -->
        <!--========== FOOTER ==========-->
    <footer class="footer">
        <!-- Copyright -->
        <div class="content container">
            <div class="row">
                <div class="col-xs-12 text-center">
                    <p class="margin-b-0">
                    <p>
                        <a href="/">首页</a> | 
                        <a href="/free-node/">免费节点</a> | 
                        <a href="/news/">新闻资讯</a> |
                        <a href="/about-us.htm">关于我们</a> |
                        <a href="/disclaimer.htm">免责申明</a> |
                        <a href="/privacy.htm">隐私申明</a> |
                        <a href="/sitemap.xml">网站地图</a>
                    </p>
                        <a href="/">Mac V2ray机场节点订阅分享</a> 版权所有 Powered by WordPress
                    </p>
                </div>
            </div>
            <!--// end row -->
        </div>
        <!-- End Copyright -->
    </footer>
    <!--========== END FOOTER ==========-->
    <!-- Back To Top -->
    <a href="javascript:void(0);" class="js-back-to-top back-to-top">Top</a>
    <!-- JAVASCRIPTS(Load javascripts at bottom, this will reduce page load time) -->
    <!-- CORE PLUGINS -->
    <script src="/assets/website/js/frontend/macv2ray/jquery.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/jquery-migrate.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/bootstrap/js/bootstrap.min.js" type="text/javascript"></script>
    <!-- PAGE LEVEL PLUGINS -->
    <script src="/assets/website/js/frontend/macv2ray/jquery.easing.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/jquery.back-to-top.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/jquery.smooth-scroll.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/jquery.wow.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/swiper/js/swiper.jquery.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/magnific-popup/jquery.magnific-popup.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/masonry/jquery.masonry.pkgd.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/masonry/imagesloaded.pkgd.min.js" type="text/javascript"></script>
    <!-- PAGE LEVEL SCRIPTS -->
    <script src="/assets/website/js/frontend/macv2ray/layout.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/components/wow.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/components/swiper.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/components/maginific-popup.min.js" type="text/javascript"></script>
    <script src="/assets/website/js/frontend/macv2ray/components/masonry.min.js" type="text/javascript"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script>
    <script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>